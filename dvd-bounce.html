<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>DVD Bounce — Swarm (DOM)</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: transparent;
      overflow: hidden;
    }
    #stage {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: transparent;
    }
    .sprite {
      position: absolute;
      will-change: transform;
      image-rendering: auto;
      pointer-events: none;
      user-select: none;
    }
  </style>
</head>
<body>
<div id="stage"></div>

<script>
(() => {
  // ---------- Options ----------
  const OPTIONS = {
    // assets
    pngURL: "https://i.imgur.com/n6hDfJt.png",  // chair PNG (74x112)
    gifURL: "https://i.imgur.com/6CXMtbT.gif",  // animated GIF (112x112)
    tintColor: "#ffa500",                       // orange for rank 2

    // sizing: draw height; width keeps aspect
    targetH: 112,

    // motion & behavior
    startCount: 3,
    maxCount: 6,              // hard cap you asked for
    startSpeed: 280,          // px/s
    boostOnCorner: 1.06,      // 6% bump each perfect corner
    maxSpeed: 800,            // clamp
    cornerCooldownMs: 350,    // per-sprite debounce
    minAngleSeparationDeg: 12 // reduce duplicate directions at spawn
  };

  // URL overrides (optional): ?start=3&max=6&h=112&speed=300&boost=1.08&cap=900&png=...&gif=...&color=%23ff6a00
  const qs = new URLSearchParams(location.search);
  if (qs.has("start")) OPTIONS.startCount = Math.max(1, +qs.get("start"));
  if (qs.has("max"))   OPTIONS.maxCount   = Math.max(1, +qs.get("max"));
  if (qs.has("h"))     OPTIONS.targetH    = Math.max(8, +qs.get("h"));
  if (qs.has("speed")) OPTIONS.startSpeed = Math.max(20, +qs.get("speed"));
  if (qs.has("boost")) OPTIONS.boostOnCorner = Math.max(1.0, +qs.get("boost"));
  if (qs.has("cap"))   OPTIONS.maxSpeed   = Math.max(OPTIONS.startSpeed, +qs.get("cap"));
  if (qs.has("png"))   OPTIONS.pngURL     = qs.get("png");
  if (qs.has("gif"))   OPTIONS.gifURL     = qs.get("gif");
  if (qs.has("color")) OPTIONS.tintColor  = qs.get("color");

  const stage = document.getElementById("stage");

  // ---------- Load base PNG first, then make tint, then load GIF ----------
  function loadImg(src) {
    return new Promise((res, rej) => {
      const img = new Image();
      img.onload = () => res(img);
      img.onerror = rej;
      img.src = src;
    });
  }

  function makeTinted(srcImg, color) {
    const w = srcImg.naturalWidth || srcImg.width;
    const h = srcImg.naturalHeight || srcImg.height;
    const off = document.createElement("canvas");
    off.width = w; off.height = h;
    const ctx = off.getContext("2d");
    ctx.drawImage(srcImg, 0, 0, w, h);
    ctx.globalCompositeOperation = "source-atop";
    ctx.fillStyle = color;
    ctx.fillRect(0, 0, w, h);
    ctx.globalCompositeOperation = "source-over";
    return off.toDataURL("image/png");
  }

  Promise.all([loadImg(OPTIONS.pngURL), loadImg(OPTIONS.gifURL)]).then(([basePNG, gifIMG]) => {
    const orangeDataURL = makeTinted(basePNG, OPTIONS.tintColor);

    // Natural sizes
    const baseW = basePNG.naturalWidth || basePNG.width;
    const baseH = basePNG.naturalHeight || basePNG.height;
    const gifW  = gifIMG.naturalWidth  || gifIMG.width;
    const gifH  = gifIMG.naturalHeight || gifIMG.height;

    // Target sizes (preserve aspect)
    const PNG_W  = Math.round(baseW * (OPTIONS.targetH / baseH));
    const PNG_H  = OPTIONS.targetH;
    const GIF_W  = Math.round(gifW  * (OPTIONS.targetH / gifH));
    const GIF_H  = OPTIONS.targetH;

    // Stage helpers
    const EPS = 0.75;
    const W = () => stage.clientWidth;
    const H = () => stage.clientHeight;

    function clampedSpeed(vx, vy) {
      const mag = Math.hypot(vx, vy) || 1;
      if (mag <= OPTIONS.maxSpeed) return {vx, vy};
      const k = OPTIONS.maxSpeed / mag;
      return {vx: vx * k, vy: vy * k};
    }

    function setSpeedMag(sprite, newMag) {
      const cur = Math.hypot(sprite.vx, sprite.vy) || 1;
      const k = newMag / cur;
      let vx = sprite.vx * k, vy = sprite.vy * k;
      ({vx, vy} = clampedSpeed(vx, vy));
      sprite.vx = vx; sprite.vy = vy;
    }

    function atEdgeX(x, w) {
      return Math.abs(x - 0) <= EPS || Math.abs(x - (W() - w)) <= EPS;
    }
    function atEdgeY(y, h) {
      return Math.abs(y - 0) <= EPS || Math.abs(y - (H() - h)) <= EPS;
    }

    // Stage 0 = PNG, 1 = orange PNG, 2 = GIF (animated). They only rank up on perfect corner.
    function applyStage(sprite) {
      if (sprite.stage === 0) {
        sprite.el.src = OPTIONS.pngURL;
        sprite.w = PNG_W; sprite.h = PNG_H;
      } else if (sprite.stage === 1) {
        sprite.el.src = orangeDataURL;
        sprite.w = PNG_W; sprite.h = PNG_H;
      } else {
        sprite.el.src = OPTIONS.gifURL;
        sprite.w = GIF_W; sprite.h = GIF_H;
      }
      // Apply size via CSS to ensure DOM img matches our math
      sprite.el.style.width = sprite.w + "px";
      sprite.el.style.height = sprite.h + "px";
    }

    function randomAngleSeparated(prevAngle) {
      let a = Math.random() * Math.PI * 2;
      if (prevAngle != null) {
        const sep = OPTIONS.minAngleSeparationDeg * Math.PI / 180;
        if (Math.abs(a - prevAngle) < sep) a += sep;
      }
      return a;
    }

    const sprites = [];

    function rectOverlap(a, b) {
      return !(a.x + a.w <= b.x || b.x + b.w <= a.x || a.y + a.h <= b.y || b.y + b.h <= a.y);
    }

    function spawn(stageSeed = 0, prevAngle = null, attempts = 16) {
      // build DOM node
      const el = document.createElement("img");
      el.className = "sprite";
      stage.appendChild(el);

      const sprite = {
        el,
        stage: stageSeed % 3, // all start as 0; we’ll pass 0 at init per your spec
        x: 0, y: 0,
        w: PNG_W, h: PNG_H,
        vx: 0, vy: 0,
        cooldownUntil: 0
      };
      sprite.stage = 0; // force start at chair PNG
      applyStage(sprite);

      // random non-overlapping position
      const pad = 3;
      for (let t = 0; t < attempts; t++) {
        const nx = Math.random() * Math.max(1, (W() - sprite.w - pad*2)) + pad;
        const ny = Math.random() * Math.max(1, (H() - sprite.h - pad*2)) + pad;
        let collides = false;
        for (const s of sprites) {
          if (rectOverlap({x:nx,y:ny,w:sprite.w,h:sprite.h}, s)) { collides = true; break; }
        }
        if (!collides) { sprite.x = nx; sprite.y = ny; break; }
      }

      // velocity
      const a = randomAngleSeparated(prevAngle);
      let vx = Math.cos(a) * OPTIONS.startSpeed;
      let vy = Math.sin(a) * OPTIONS.startSpeed;
      ({vx, vy} = clampedSpeed(vx, vy));
      sprite.vx = vx; sprite.vy = vy;

      sprites.push(sprite);
      return sprite;
    }

    // seed with exactly 3
    let prevA = null;
    for (let i = 0; i < OPTIONS.startCount; i++) {
      const s = spawn(0, prevA);
      prevA = Math.atan2(s.vy, s.vx);
    }

    // physics loop
    let last = performance.now();

    function tick(now) {
      const dt = (now - last) / 1000;
      last = now;

      // move + wall bounces
      for (const s of sprites) {
        let nx = s.x + s.vx * dt;
        let ny = s.y + s.vy * dt;

        let hitX = false, hitY = false;

        if (nx <= 0) { nx = 0; s.vx = Math.abs(s.vx); hitX = true; }
        else if (nx + s.w >= W()) { nx = W() - s.w; s.vx = -Math.abs(s.vx); hitX = true; }

        if (ny <= 0) { ny = 0; s.vy = Math.abs(s.vy); hitY = true; }
        else if (ny + s.h >= H()) { ny = H() - s.h; s.vy = -Math.abs(s.vy); hitY = true; }

        s.x = nx; s.y = ny;

        const corner = (hitX && hitY) || (atEdgeX(s.x, s.w) && atEdgeY(s.y, s.h));
        if (corner && now >= s.cooldownUntil) {
          // rank up: 0 -> 1 -> 2 -> 0 ...
          s.stage = (s.stage + 1) % 3;
          applyStage(s);

          // speed boost
          const boosted = Math.min(OPTIONS.maxSpeed, Math.hypot(s.vx, s.vy) * OPTIONS.boostOnCorner);
          setSpeedMag(s, boosted);

          // spawn new if under cap
          if (sprites.length < OPTIONS.maxCount) {
            const newbie = spawn(0, Math.atan2(s.vy, s.vx));
          }

          // debounce
          s.cooldownUntil = now + OPTIONS.cornerCooldownMs;
        }
      }

      // pairwise AABB collisions with simple elastic response
      for (let i = 0; i < sprites.length; i++) {
        for (let j = i + 1; j < sprites.length; j++) {
          const A = sprites[i], B = sprites[j];
          if (!rectOverlap(A, B)) continue;

          const axC = A.x + A.w / 2, ayC = A.y + A.h / 2;
          const bxC = B.x + B.w / 2, byC = B.y + B.h / 2;

          const overlapX = (A.w + B.w) / 2 - Math.abs(axC - bxC);
          const overlapY = (A.h + B.h) / 2 - Math.abs(ayC - byC);
          if (overlapX <= 0 || overlapY <= 0) continue;

          if (overlapX < overlapY) {
            const push = overlapX / 2 + 0.1;
            if (axC < bxC) { A.x -= push; B.x += push; }
            else { A.x += push; B.x -= push; }
            const tmp = A.vx; A.vx = B.vx; B.vx = tmp;
          } else {
            const push = overlapY / 2 + 0.1;
            if (ayC < byC) { A.y -= push; B.y += push; }
            else { A.y += push; B.y -= push; }
            const tmp = A.vy; A.vy = B.vy; B.vy = tmp;
          }

          // clamp speeds
          ({vx: A.vx, vy: A.vy} = clampedSpeed(A.vx, A.vy));
          ({vx: B.vx, vy: B.vy} = clampedSpeed(B.vx, B.vy));
        }
      }

      // draw (via CSS transform so GIFs animate naturally)
      for (const s of sprites) {
        s.el.style.transform = `translate(${Math.round(s.x)}px, ${Math.round(s.y)}px)`;
      }

      requestAnimationFrame(tick);
    }

    requestAnimationFrame(tick);
  }).catch(err => {
    console.error("Asset load failed:", err);
    // visual fallback: a single bouncing div so OBS isn't blank
    const box = document.createElement("div");
    box.style.position = "absolute";
    box.style.width = "100px";
    box.style.height = "100px";
    box.style.background = "rgba(255,255,255,0.8)";
    stage.appendChild(box);
    let x=10,y=10,vx=200,vy=160,last=performance.now();
    function loop(now){
      const dt=(now-last)/1000; last=now;
      x+=vx*dt; y+=vy*dt;
      const W=stage.clientWidth,H=stage.clientHeight;
      if(x<0||x+100>W)vx*=-1;
      if(y<0||y+100>H)vy*=-1;
      box.style.transform=`translate(${x}px,${y}px)`;
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  });
})();
</script>
</body>
</html>
