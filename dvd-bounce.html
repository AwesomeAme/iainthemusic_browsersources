<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>DVD Bounce â€” Swarm (DOM)</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: transparent;
      overflow: hidden;
    }
    #stage {
      position: relative;
      /* we'll size this in JS to exact pixels so OBS always reports non-zero */
      background: transparent;
      overflow: hidden;
    }
    .sprite {
      position: absolute;
      will-change: transform;
      image-rendering: auto;
      pointer-events: none;
      user-select: none;
    }
  </style>
</head>
<body>
<div id="stage"></div>

<script>
(() => {
  const OPTIONS = {
    pngURL: "https://i.imgur.com/n6hDfJt.png",   // chair PNG (74x112)
    gifURL: "https://i.imgur.com/6CXMtbT.gif",   // animated GIF (112x112)
    tintColor: "#ffa500",                        // orange rank

    targetH: 112,         // drawn height (px), width keeps aspect
    startCount: 3,
    maxCount: 6,          // hard cap
    startSpeed: 280,      // px/s
    boostOnCorner: 1.06,  // 6% bump per perfect corner
    maxSpeed: 800,        // clamp
    cornerCooldownMs: 350,
    minAngleSeparationDeg: 12
  };

  // Optional URL overrides
  const qs = new URLSearchParams(location.search);
  if (qs.has("start")) OPTIONS.startCount = Math.max(1, +qs.get("start"));
  if (qs.has("max"))   OPTIONS.maxCount   = Math.max(1, +qs.get("max"));
  if (qs.has("h"))     OPTIONS.targetH    = Math.max(8, +qs.get("h"));
  if (qs.has("speed")) OPTIONS.startSpeed = Math.max(20, +qs.get("speed"));
  if (qs.has("boost")) OPTIONS.boostOnCorner = Math.max(1.0, +qs.get("boost"));
  if (qs.has("cap"))   OPTIONS.maxSpeed   = Math.max(OPTIONS.startSpeed, +qs.get("cap"));
  if (qs.has("png"))   OPTIONS.pngURL     = qs.get("png");
  if (qs.has("gif"))   OPTIONS.gifURL     = qs.get("gif");
  if (qs.has("color")) OPTIONS.tintColor  = qs.get("color");

  const stage = document.getElementById("stage");

  // Ensure stage always has real pixel size (fixes 0x0 spawn bug in OBS)
  function sizeStageToWindow() {
    const w = Math.max(1, Math.floor(window.innerWidth));
    const h = Math.max(1, Math.floor(window.innerHeight));
    stage.style.width  = w + "px";
    stage.style.height = h + "px";
    return { w, h };
  }
  sizeStageToWindow();
  addEventListener("resize", sizeStageToWindow);

  // Helpers to read current stage size
  const W = () => stage.clientWidth  || Math.max(1, Math.floor(window.innerWidth));
  const H = () => stage.clientHeight || Math.max(1, Math.floor(window.innerHeight));

  // Image loading with CORS so Imgur is happy
  function loadImg(src) {
    return new Promise((res, rej) => {
      const img = new Image();
      img.decoding = "async";
      img.crossOrigin = "anonymous";
      img.onload = () => res(img);
      img.onerror = (e) => rej(e);
      img.src = src;
    });
  }

  function makeTinted(srcImg, color) {
    const w = srcImg.naturalWidth || srcImg.width;
    const h = srcImg.naturalHeight || srcImg.height;
    const off = document.createElement("canvas");
    off.width = w; off.height = h;
    const ctx = off.getContext("2d");
    ctx.drawImage(srcImg, 0, 0, w, h);
    ctx.globalCompositeOperation = "source-atop";
    ctx.fillStyle = color;
    ctx.fillRect(0, 0, w, h);
    ctx.globalCompositeOperation = "source-over";
    return off.toDataURL("image/png");
  }

  Promise.all([loadImg(OPTIONS.pngURL), loadImg(OPTIONS.gifURL)]).then(([basePNG, gifIMG]) => {
    const orangeDataURL = makeTinted(basePNG, OPTIONS.tintColor);

    const baseW = basePNG.naturalWidth || basePNG.width;
    const baseH = basePNG.naturalHeight || basePNG.height;
    const gifW  = gifIMG.naturalWidth  || gifIMG.width;
    const gifH  = gifIMG.naturalHeight || gifIMG.height;

    const PNG_W = Math.round(baseW * (OPTIONS.targetH / baseH));
    const PNG_H = OPTIONS.targetH;
    const GIF_W = Math.round(gifW  * (OPTIONS.targetH / gifH));
    const GIF_H = OPTIONS.targetH;

    // Physics + sprites
    const sprites = [];
    const EPS = 0.75;

    function clampedSpeed(vx, vy) {
      const mag = Math.hypot(vx, vy) || 1;
      if (mag <= OPTIONS.maxSpeed) return { vx, vy };
      const k = OPTIONS.maxSpeed / mag;
      return { vx: vx * k, vy: vy * k };
    }
    function setSpeedMag(s, newMag) {
      const cur = Math.hypot(s.vx, s.vy) || 1;
      const k = newMag / cur;
      let vx = s.vx * k, vy = s.vy * k;
      ({vx, vy} = clampedSpeed(vx, vy));
      s.vx = vx; s.vy = vy;
    }
    function atEdgeX(x, w) { return Math.abs(x - 0) <= EPS || Math.abs(x - (W() - w)) <= EPS; }
    function atEdgeY(y, h) { return Math.abs(y - 0) <= EPS || Math.abs(y - (H() - h)) <= EPS; }

    function applyStage(s) {
      // 0 = PNG, 1 = orange PNG, 2 = GIF
      if (s.stage === 0) {
        s.el.src = OPTIONS.pngURL; s.w = PNG_W; s.h = PNG_H;
      } else if (s.stage === 1) {
        s.el.src = orangeDataURL;  s.w = PNG_W; s.h = PNG_H;
      } else {
        s.el.src = OPTIONS.gifURL; s.w = GIF_W; s.h = GIF_H;
      }
      s.el.style.width  = s.w + "px";
      s.el.style.height = s.h + "px";
    }

    function rectOverlap(a, b) {
      return !(a.x + a.w <= b.x || b.x + b.w <= a.x || a.y + a.h <= b.y || b.y + b.h <= a.y);
    }

    function randomAngleSeparated(prevAngle) {
      let a = Math.random() * Math.PI * 2;
      if (prevAngle != null) {
        const sep = OPTIONS.minAngleSeparationDeg * Math.PI / 180;
        if (Math.abs(a - prevAngle) < sep) a += sep;
      }
      return a;
    }

    function spawn(prevAngle = null, attempts = 24) {
      const el = document.createElement("img");
      el.className = "sprite";
      stage.appendChild(el);

      const s = {
        el, stage: 0, // start as chair
        x: 0, y: 0, w: PNG_W, h: PNG_H,
        vx: 0, vy: 0,
        cooldownUntil: 0
      };
      applyStage(s);

      const pad = 3;
      const width  = W();
      const height = H();

      // If stage somehow still 0x0, delay spawn a tick
      if (width <= 0 || height <= 0) {
        requestAnimationFrame(() => spawn(prevAngle, attempts));
        el.remove();
        return null;
      }

      for (let t = 0; t < attempts; t++) {
        const nx = Math.random() * Math.max(1, (width - s.w - pad * 2)) + pad;
        const ny = Math.random() * Math.max(1, (height - s.h - pad * 2)) + pad;
        let collides = false;
        for (const o of sprites) {
          if (rectOverlap({ x: nx, y: ny, w: s.w, h: s.h }, o)) { collides = true; break; }
        }
        if (!collides) { s.x = nx; s.y = ny; break; }
      }

      const a = randomAngleSeparated(prevAngle);
      let vx = Math.cos(a) * OPTIONS.startSpeed;
      let vy = Math.sin(a) * OPTIONS.startSpeed;
      ({ vx, vy } = clampedSpeed(vx, vy));
      s.vx = vx; s.vy = vy;

      sprites.push(s);
      return s;
    }

    // Wait until stage has size, then seed exactly 3
    function seedWhenReady() {
      if (W() > 0 && H() > 0) {
        let prevA = null;
        for (let i = 0; i < OPTIONS.startCount; i++) {
          const s = spawn(prevA);
          if (s) prevA = Math.atan2(s.vy, s.vx);
        }
        startLoop();
      } else {
        requestAnimationFrame(seedWhenReady);
      }
    }

    let last = performance.now();
    function startLoop() {
      function tick(now) {
        const dt = (now - last) / 1000;
        last = now;

        // Move + wall bounces
        for (const s of sprites) {
          let nx = s.x + s.vx * dt;
          let ny = s.y + s.vy * dt;

          let hitX = false, hitY = false;

          if (nx <= 0) { nx = 0; s.vx = Math.abs(s.vx); hitX = true; }
          else if (nx + s.w >= W()) { nx = W() - s.w; s.vx = -Math.abs(s.vx); hitX = true; }

          if (ny <= 0) { ny = 0; s.vy = Math.abs(s.vy); hitY = true; }
          else if (ny + s.h >= H()) { ny = H() - s.h; s.vy = -Math.abs(s.vy); hitY = true; }

          s.x = nx; s.y = ny;

          const corner = (hitX && hitY) || (atEdgeX(s.x, s.w) && atEdgeY(s.y, s.h));
          if (corner && now >= s.cooldownUntil) {
            // rank up
            s.stage = (s.stage + 1) % 3;
            const oldW = s.w, oldH = s.h;
            applyStage(s);

            // Keep inside if size changed
            if (s.x + s.w > W()) s.x = W() - s.w;
            if (s.y + s.h > H()) s.y = H() - s.h;

            // speed boost
            const boosted = Math.min(OPTIONS.maxSpeed, Math.hypot(s.vx, s.vy) * OPTIONS.boostOnCorner);
            setSpeedMag(s, boosted);

            // spawn new until cap
            if (sprites.length < OPTIONS.maxCount) {
              spawn(Math.atan2(s.vy, s.vx));
            }

            s.cooldownUntil = now + OPTIONS.cornerCooldownMs;
          }
        }

        // Pairwise AABB collisions
        for (let i = 0; i < sprites.length; i++) {
          for (let j = i + 1; j < sprites.length; j++) {
            const A = sprites[i], B = sprites[j];
            if (!rectOverlap(A, B)) continue;

            const axC = A.x + A.w / 2, ayC = A.y + A.h / 2;
            const bxC = B.x + B.w / 2, byC = B.y + B.h / 2;

            const overlapX = (A.w + B.w) / 2 - Math.abs(axC - bxC);
            const overlapY = (A.h + B.h) / 2 - Math.abs(ayC - byC);
            if (overlapX <= 0 || overlapY <= 0) continue;

            if (overlapX < overlapY) {
              const push = overlapX / 2 + 0.1;
              if (axC < bxC) { A.x -= push; B.x += push; }
              else { A.x += push; B.x -= push; }
              const tvx = A.vx; A.vx = B.vx; B.vx = tvx;
            } else {
              const push = overlapY / 2 + 0.1;
              if (ayC < byC) { A.y -= push; B.y += push; }
              else { A.y += push; B.y -= push; }
              const tvy = A.vy; A.vy = B.vy; B.vy = tvy;
            }

            ({ vx: A.vx, vy: A.vy } = clampedSpeed(A.vx, A.vy));
            ({ vx: B.vx, vy: B.vy } = clampedSpeed(B.vx, B.vy));
          }
        }

        // Draw
        for (const s of sprites) {
          s.el.style.transform = `translate(${Math.round(s.x)}px, ${Math.round(s.y)}px)`;
        }

        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);
    }

    // Kick everything off after stage has non-zero size
    seedWhenReady();

  }).catch(err => {
    console.error("Asset load failed:", err);
    // emergency fallback block
    sizeStageToWindow();
    const box = document.createElement("div");
    box.style.position = "absolute";
    box.style.width = "100px";
    box.style.height = "100px";
    box.style.background = "rgba(255,255,255,0.8)";
    stage.appendChild(box);
    let x=10,y=10,vx=200,vy=160,last=performance.now();
    function loop(now){
      const dt=(now-last)/1000; last=now;
      const width=W(), height=H();
      x+=vx*dt; y+=vy*dt;
      if(x<0||x+100>width)vx*=-1;
      if(y<0||y+100>height)vy*=-1;
      box.style.transform=`translate(${x}px,${y}px)`;
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  });
})();
</script>
</body>
</html>
